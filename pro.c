#include<stdio.h>
#include<pthread.h>
#include<time.h>
#include<stdlib.h>
#include<unistd.h>
#include<semaphore.h>
sem_t mutex,empty,full;
// we will declare three semaphore that we will use in the following code.
static int i=0,buff[20],bs;
// this is the buffer that we will use nad bs is for buffer size;
void *pro()
	{
	//producer function
	while(1)
		{
		if(i==bs)
		{
		printf("\nbuffer is full now exiting");
		exit(0);//exit condition for the loop 
		}
		sem_wait(&empty);
		//this will decrement the value of empty. As initially the buffer is empty so it is 
		//initialized with 10 every time this command will run it will decrement the value
		sem_wait(&mutex);
		// this will decrement the value of mutex. As it is initialized with 1 will go to 0.          
		//After that no other process will be able to enter as it cannot go beyond 0.
		buff[i]=rand()%100;
		//this will generate a random number and will store in it buffer
		printf("\nProducer produced item %d",buff[i]);
                i++;
		// this will show the random number that is genrated by the Producer thread and
		// stored in the buffer
		printf("\nItem in buffer after producing : ");
		for(int y=0;y<i;y++)
		printf("\t%d ",buff[y]);
		// this will show all the elements in the buffer after producing the number
		sem_post(&mutex);
		// this will increment the value of mutex to 1. Resulting in the unlocking the 
		//mutex for other processes.
		sem_post(&full);
		// this will increment the value of full as now there is one item in the buffer. So
		//full will be incremented from 0 to 1 initially.
		sleep(1 + rand()%2);
		//this function will let the thread sleep for the time generated by the rand() fun.
		}
	}
void *con()
	{
	//Consumer function
	while(1)
	{
		sem_wait(&full);
		//Since we are consuming the value the Full will be decremented as it represent                          		
		//the Items in the buffer.
		sem_wait(&mutex);
 		// this will decrement the value of mutex. As it is initialized with 1 will go to 0.          
		//After that no other process will be able to enter as it cannot go beyond 0.
		i--;
		printf("\nThe consumer consumed %d",buff[i]);
		// this will show the item consumed;
		printf("\nRemaining elemnets in buffer are : "); 
		// this loop will show the elements that remained after consuming 
		for(int y=0;y<i;y++)
		printf("\t%d",buff[y]);
		sem_post(&mutex);
		// this will increment the value of mutex to 1. Resulting in the unlocking 
		//the mutex for other processes.
		sem_post(&empty);
		// this will increment the value of empty as now there is one item less in 
		//the buffer. So empty will be incremented from 0 to 1 initially
		sleep(1 + rand()%6);
		//this function will let the thread sleep for the time generated by the rand() 4
		//fun. Note that consumer sleeps time is more than that of Producer.
		}
}
void main()
{
pthread_t p1,c2;
//thread declaration
sem_init(&mutex,0,1);
sem_init(&full,0,0);
//semaphore intilisation
printf("\nEnter the Buffer size\n");
scanf("%d",&bs);
sem_init(&empty,0,bs);
	//initializing empty semaphore with the buffer value
	for(int i=0;;)
	{
	pthread_create(&p1,NULL,pro,NULL);
	pthread_create(&c2,NULL,con,NULL);
	pthread_join(p1,NULL);
	pthread_join(c2,NULL);
	}
//thread mapping into main function
}
